import{a6 as co,l as lo,T as uo,a7 as ro}from"./entry.d3a8535e.js";import{c as m,a as ao}from"./sha256.bbb7a478.js";import{I as po,e as R,C as G,l as to,J as eo,u as _o,b as io,a as z,s as B,T as no,K as so,p as H}from"./pool.f6a0001b.js";import{C as mo,V as W}from"./index.5e8796c0.js";import{D as t}from"./decimal.0e8aa3f1.js";function Q(e){const p={launchpad:m[e||"Sui"].launchpad,ido:m[e||"Sui"].ido,xcetus:m[e||"Sui"].xcetus,xcetus_dividends:m[e||"Sui"].xcetus_dividends,cetus_faucet:m[e||"Sui"].cetus_faucet,xtoken:m[e||"Sui"].xtoken,xtoken_dividends:m[e||"Sui"].xtoken_dividends,token_faucet:m[e||"Sui"].token_faucet,booster:m[e||"Sui"].booster,maker_bonus:m[e||"Sui"].maker_bonus,liquidity_stratefy:m[e||"Sui"].liquidity_stratefy,vaults:m[e||"Sui"].vaults},S={fullRpcUrl:localStorage.getItem(`${e}-currentRpclocal2`)||m[e||"Sui"].fullRpcUrl,simulationAccount:m[e||"Sui"].simulationAccount,cetus_config:m[e||"Sui"].cetus_config,clmm_pool:m[e||"Sui"].clmm_pool,integrate:m[e||"Sui"].integrate,deepbook:m[e||"Sui"].deepbook,deepbook_endpoint_v2:m[e||"Sui"].deepbook_endpoint_v2,aggregatorUrl:m[e||"Sui"].aggregatorUrl},c=new po(S),i=co(new mo(p,c)),y=ao(),L=lo(()=>y);uo(()=>{L.value.address&&(c.senderAddress=L.value.address)});const E=async()=>{console.log(i,"sdk###");const o=await i.Vaults.getVaultList();return o&&o.data||[]},T=async o=>await i.Vaults.getVault(o),n=async o=>{if(console.log(o,"###coinType"),c.senderAddress){const _=await i.ClmmSDK.fullClient.getBalance({owner:c.senderAddress,coinType:o});return _&&_.totalBalance}else return 0},w=o=>({transactionBlock:o,options:{showEffects:!0,showEvents:!0,showInput:!0,showRawInput:!0,showObjectChanges:!0,showBalanceChanges:!0}});return{getAutoPools:E,getLpBalance:n,deposit:async o=>{const{lowerTick:_,upperTick:P,slippage:d,rewarder_coin_types:v,isOnlyA:A,isOnlyB:b}=o;console.log(o,"params###");let r=o.fix_amount_a,a,f,O;if(A||b){const C=await i.Vaults.calculateDepositSwapAmount({lowerTick:_,upperTick:P,curSqrtPrice:o.curSqrtPrice,fix_amount_a:o.fix_amount_a,input_amount:o.coinAmount,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,clmm_pool:o.clmm_pool});console.log("swapResut: ",C),C?(f=new R(C.afterSqrtPrice),a=new R(C.swapOutAmount),f=new R(o.curSqrtPrice),O={swap_amount:C.swapInAmount,a2b:r},r=!r):(f=new R(o.curSqrtPrice),a=new R(o.coinAmount))}else f=o.curSqrtPrice,a=new R(o.coinAmount);const I=G.estLiquidityAndcoinAmountFromOneAmounts(_,P,a,r,!0,d,f),k=r?a.toString():I.tokenMaxA.toString(),x=r?I.tokenMaxB.toString():a.toString(),j=await i.Vaults.deposit({vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,amount_a:k,amount_b:x,fix_amount_a:r,slippage:d,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,rewarder_coin_types:[],swapParams:O});return w(j)},remove:async o=>{const{lowerTick:_,upperTick:P,coinTypeA:d,coinTypeB:v,receiveAmount:A,clmm_pool:b,lowerSqrtPrice:r,upperSqrtPrice:a,fix_amount_a:f,curSqrtPrice:O,slippage:I,rewarder_coin_types:k,id:x,liquidity:j,swapParams:C,isOnlyA:h,isOnlyB:q}=o,g=await T(x),$=await c.Pool.getPool(g.pool_id);let l,u,F,M,U;console.log(A,"##receiveAmount"),h||q?(l=await i.Vaults.calculateRemoveSwapAmount({lowerTick:_,upperTick:P,curSqrtPrice:$.current_sqrt_price,fix_amount_a:f,receive_amount:A,coinTypeA:d,coinTypeB:v,clmm_pool:b}),console.log(l,"swapResut###"),l&&(u=G.getCoinAmountFromLiquidity(new R(l.liquidity),new R($.current_sqrt_price),r,a,!1),F=W.get_protocol_fee_amount(g,u.coinA.toString()),M=W.get_protocol_fee_amount(g,u.coinB.toString()),U=W.get_lp_amount_by_liquidity(g,l.liquidity))):(u=G.getCoinAmountFromLiquidity(new R(j),O,r,a,!1),F=W.get_protocol_fee_amount(g,u.coinA.toString()),M=W.get_protocol_fee_amount(g,u.coinB.toString()),U=o.lpTokenAmount);const V={vault_id:o.id,clmm_pool:o.clmm_pool,lp_token_type:o.lp_token_type,coinTypeA:o.coinTypeA,coinTypeB:o.coinTypeB,lp_token_amount:U.toString(),min_amount_a:to(eo(u.coinA.toString()).sub(F).toString(),0)||"",min_amount_b:to(eo(u.coinB.toString()).sub(M).toString(),0)||"",rewarder_coin_types:[]};(h||q)&&(V.swapParams={a2b:!f,swap_amount:l==null?void 0:l.swapInAmount});const J=await i.Vaults.remove(V);return w(J)},getAutoPool:T,calculateDepositSwapAmount:async o=>{const{lowerTick:_,upperTick:P,curSqrtPrice:d,fix_amount_a:v,input_amount:A,coinTypeA:b,coinTypeB:r,clmm_pool:a}=o;return console.log(o,"params###"),await i.Vaults.calculateDepositSwapAmount({lowerTick:_,upperTick:P,curSqrtPrice:d,fix_amount_a:v,input_amount:A,coinTypeA:b,coinTypeB:r,clmm_pool:a})},calculateRemoveSwapAmount:async o=>{const{lowerTick:_,upperTick:P,curSqrtPrice:d,fix_amount_a:v,receiveAmount:A,coinTypeA:b,coinTypeB:r,clmm_pool:a}=o;return console.log(o,"params###"),await i.Vaults.calculateRemoveSwapAmount({lowerTick:_,upperTick:P,curSqrtPrice:d,fix_amount_a:v,receive_amount:A,coinTypeA:b,coinTypeB:r,clmm_pool:a})}}}const fo=ro("autoPool",{state:()=>({autoPoolList:[],autoPoolObj:{},positionInfoObj:{},positionInfoList:[],positionUSDObj:{},apyObj:{}}),getters:{getPoolStore(){return _o()}},actions:{async getAutoPoolList(){const p=await Q("Sui").getAutoPools();console.log(p,"list###");const S=this.getPoolStore,c=p.map(i=>({...S.poolConfigObj[i.pool_id],id:i.id,lp_token_type:i.lp_token_type,autoPoolPositionInfo:i.positins[0],is_pause:i.is_pause,total_supply:i.total_supply,liquidity:i.liquidity,protocol_fee_rate:i.protocol_fee_rate}));this.autoPoolList=c,this.autoPoolObj=Object.fromEntries(c.map((i,y)=>[i.address,i])),this.getMyAutoPoolPosition(),console.log(c,"##autoPoolList")},async getMyAutoPoolPosition(){var y,L,E;const e=Q("Sui"),p=this.autoPoolList,S=io("Sui"),c=[],{RATES:i}=this.getPoolStore;for(let T=0;T<p.length;T++){const n=p[T];console.log(n,"poolINfo###");const w=await S.getPool(n.address),s=await e.getLpBalance(p[T].lp_token_type);console.log(s,"balance##");const D=(await S.getTokenListByCoinType([p[T].lp_token_type]))[0];console.log(D,"lpInfo##");const K=((y=i[n.coinA.address])==null?void 0:y.price)||"",X=((L=i[n.coinB.address])==null?void 0:L.price)||"",o=n.autoPoolPositionInfo.tick_lower_index,_=n.autoPoolPositionInfo.tick_upper_index,P={tick_lower_index:o,tick_upper_index:_,current_sqrt_price:w==null?void 0:w.current_sqrt_price,liquidity:Number(s)>0?W.get_share_liquidity_by_amount({liquidity:n==null?void 0:n.liquidity,total_supply:n==null?void 0:n.total_supply},s):0},d=await S.getCoinAmountFromLiquidity({pool:{...n,current_sqrt_price:w==null?void 0:w.current_sqrt_price},position:P,roundUp:!1});console.log(d,"##amountInfo");const v=d.coinaAmount,A=d.coinbAmount;console.log(n.protocol_fee_rate,"##newPoolInfo.protocol_fee_rate");const b=v,r=A,a=n.coinA.decimals,f=n.coinB.decimals,O=S.TickMath.tickIndexToPrice(Number(o),a,f).toString(),I=S.TickMath.tickIndexToPrice(Number(_),a,f).toString(),k=new t(K).mul(new t(v)).toNumber(),x=new t(X).mul(new t(A)).toNumber(),j=k>0&&k<.01?"<$0.01":`$${z(B(k,2))}`,C=x>0&&x<.01?"<$0.01":`$${z(B(x,2))}`,h=no.sqrtPriceX64ToPrice(w.current_sqrt_price,a,f);let q,g;console.log(n.total_supply,"##poolInfo.total_supply");const $=await S.getCoinAmountFromLiquidity({pool:{...n,tick_lower_index:o,tick_upper_index:_,current_sqrt_price:w==null?void 0:w.current_sqrt_price},position:{...P,liquidity:n.liquidity},roundUp:!1}),l=new t($.coinaAmount).toNumber(),u=new t($.coinbAmount).toNumber();console.log(l,u,h.toString(),"###116");const F=B(new t(l).mul(new t(K)).toNumber(),2),M=B(new t(u).mul(new t(X)).toNumber(),2);if(console.log(w,"newPool##"),l>0&&u>0){const oo=new t(l).mul(h).add(new t(u));q=new t(l).mul(h).div(oo).mul(100).toNumber().toFixed(2),g=new t(u).div(oo).mul(100).toNumber().toFixed(2)}else v>0?(q=100,g=0):A>0?(q=0,g=100):(q=50,g=50);let U=0;Number(s)>0&&(U=new t(s).div(Math.pow(10,D.decimals)));const V=K&&X?B(new t(k).add(new t(x)).toString(),2):"",J=n.total_supply;console.log(K,X,d==null?void 0:d.coinaAmount,d==null?void 0:d.coinbAmount,"myLiquidityUSD###");let N=0;U>0&&J>0&&(N=new t(U).mul(Math.pow(10,D.decimals)).div(new t(J)).mul(100).toNumber()),console.log(N,"##myShare");const Z=new t(1).div(Math.pow(10,n.decimals)).toNumber();let Y=0;N>1?Y=B(N,2):N>0&&N<Z?Y=`<${Z}`:N==0?Y=0:Y=so(N,1),console.log(s,U.toString(),"###balance"),this.positionInfoObj[n.id]={tick_lower_index:o,tick_upper_index:_,current_sqrt_price:w.current_sqrt_price,myLiquidity:H(s,D.decimals),amountA:b,amountB:r,...n,lpInfo:D,myAmountAUSD:j,myAmountBUSD:C,myLiquidityUSD:V,myShare:Y,minPrice:O,maxPrice:I,poolCoinARatio:q,poolCoinBRatio:g,poolCoinANum:l,poolCoinBNum:u,poolCoinAUSD:F,poolCoinBUSD:M},c.push({tick_lower_index:o,tick_upper_index:_,current_sqrt_price:(E=n==null?void 0:n.object)==null?void 0:E.current_sqrt_price,myLiquidity:H(s,D.decimals),amountA:b,amountB:r,...n,lpInfo:D,myAmountAUSD:j,myAmountBUSD:C,myLiquidityUSD:V,myShare:Y,minPrice:O,maxPrice:I,poolCoinARatio:q,poolCoinBRatio:g,poolCoinANum:l,poolCoinBNum:u,poolCoinAUSD:F,poolCoinBUSD:M})}this.positionInfoList=c,console.log(this.positionInfoObj,"this.positionInfoObj###"),console.log(this.positionInfoList,"###this.positionInfoList")},async updatePositionItem(e){var U,V;const p=Q("Sui"),S=io("Sui"),c=await p.getAutoPool(e),i=await S.getPool(c.pool_id);console.log("newPoolInfo:",c),console.log("this.positionInfoObj[id]:",this.positionInfoObj[e]);const y={...this.positionInfoObj[e],autoPoolPositionInfo:c.positins[0]},L=await p.getLpBalance(y.lp_token_type),E=(await S.getTokenListByCoinType([y.lp_token_type]))[0];console.log(L,"###balance updatePositionItem");const T=y.autoPoolPositionInfo.tick_lower_index,n=y.autoPoolPositionInfo.tick_upper_index,w={tick_lower_index:T,tick_upper_index:n,current_sqrt_price:i.current_sqrt_price,liquidity:W.get_share_liquidity_by_amount({liquidity:c==null?void 0:c.liquidity,total_supply:c==null?void 0:c.total_supply},L)},s=S.getCoinAmountFromLiquidity({pool:{current_sqrt_price:i.current_sqrt_price,...y},position:w,roundUp:!1});console.log(s,"amountInfo###");const D=s.coinaAmount,K=s.coinbAmount,X=s.coinaAmount,o=s.coinbAmount,{RATES:_}=this.getPoolStore,P=c.total_supply,d=2,v=2,A=((U=_[y.coinA.address])==null?void 0:U.price)||0,b=((V=_[y.coinB.address])==null?void 0:V.price)||0,r=new t(A).mul(new t(s==null?void 0:s.coinaAmount)).toNumber(),a=new t(b).mul(new t(s==null?void 0:s.coinbAmount)).toNumber(),f=r>0&&r<.01?"<$0.01":`$${z(B(r,2))}`,O=a>0&&a<.01?"<$0.01":`$${z(B(a,2))}`;let I=new t(0);Number(L)>0&&(I=new t(L).div(Math.pow(10,E.decimals)));const k=new t(I).mul(Math.pow(10,y.lpInfo.decimals)).div(new t(P)).mul(100).toNumber();let x=0;const j=new t(1).div(Math.pow(10,y.decimals)).toNumber(),C=A&&b?B(new t(r).add(new t(a)).toString(),2):"";console.log(A,b,s==null?void 0:s.coinaAmount,s==null?void 0:s.coinbAmount,"myLiquidityUSD###"),k>1?x=B(k,2):k>0&&k<j?x=`<${j}`:x=so(k,1);let h,q;const g=no.sqrtPriceX64ToPrice(i.current_sqrt_price,d,v),$=await S.getCoinAmountFromLiquidity({pool:{...y,tick_lower_index:T,tick_upper_index:n,current_sqrt_price:i==null?void 0:i.current_sqrt_price},position:{...w,liquidity:c.liquidity},roundUp:!1}),l=new t($.coinaAmount).toNumber(),u=new t($.coinbAmount).toNumber();console.log(l,u,g.toString(),"###116");const F=B(new t(l).mul(new t(A)).toNumber(),2),M=B(new t(u).mul(new t(b)).toNumber(),2);if(console.log(i,"newPool##"),l>0&&u>0){const J=new t(l).mul(g).add(new t(u));h=new t(l).mul(g).div(J).mul(100).toNumber().toFixed(2),q=new t(u).div(J).mul(100).toNumber().toFixed(2)}else D>0?(h=100,q=0):K>0?(h=0,q=100):(h=50,q=50);this.positionInfoObj[e]={...y,tick_lower_index:T,tick_upper_index:n,current_sqrt_price:i.current_sqrt_price,myLiquidity:H(L,E.decimals),amountA:X,amountB:o,myShare:x,myAmountAUSD:f,myAmountBUSD:O,myLiquidityUSD:C,poolCoinARatio:h,poolCoinBRatio:q,poolCoinANum:l,poolCoinBNum:u,poolCoinAUSD:F,poolCoinBUSD:M},console.log(this.positionInfoObj[e],"###this.positionInfoObj[id]")},async getAutoPoolAPY(){try{const{data:e}=await fetch(`${m.Sui.api}/v2/sui/auto_pools`).then(p=>p.json());e&&e.pools&&e.pools.length>0&&(this.apyObj=Object.fromEntries(e.pools.map((p,S)=>[p.object_id,{...p,apr:p.apr.replace("%","")>0&&p.apr.replace("%","")<.01?"<0.01%":B(p.apr.replace("%",""),2)+"%",resultApr:p.apr.replace("%","")}])),console.log(this.apyObj,"data##"))}catch{this.apyObj={}}}}});export{Q as a,fo as u};
